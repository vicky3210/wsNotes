## 测试多返回值函数的错误

Go 语言的函数经常使用两个返回值来表示执行是否成功：返回某个值以及 `true` 表示成功；返回零值（或 `nil`）和 `false` 表示失败。当不使用 `true` 或 `false` 的时候，也可以使用一个 `error` 类型的变量来代替作为第二个返回值：成功执行的话，`error` 的值为 `nil`，否则就会包含相应的错误信息（Go 语言中的错误类型为 `error: var err error`）。这样一来，就很明显需要用一个 `if` 语句来测试执行结果；由于其符号的原因，这样的形式又称之为 `comma,ok` 模式（pattern）。

string_conversion2.go

```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	var orig string = "ABC"
	// var an int
	var newS string
	// var err error

	fmt.Printf("The size of ints is: %d\n", strconv.IntSize)	  
	// anInt, err = strconv.Atoi(origStr)
	an, err := strconv.Atoi(orig)
	if err != nil {
		fmt.Printf("orig %s is not an integer - exiting with error\n", orig)
		return
	}
	fmt.Printf("The integer is %d\n", an)
	an = an + 5
	newS = strconv.Itoa(an)
	fmt.Printf("The new string is: %s\n", newS)
}
```

习惯用法

```go
value, err := pack1.Function1(param1)
if err != nil {
	fmt.Printf("An error occured in pack1.Function1 with parameter %v", param1)
	return err
}
// 未发生错误，继续执行：
```

如果我们想要在错误发生的同时终止程序的运行，我们可以使用 os 包的 Exit 函数：

习惯用法

```go
if err != nil {
	fmt.Printf("Program stopping with error %v", err)
	os.Exit(1)
}
```

可以将错误的获取放置在 if 语句的初始化部分：

习惯用法

```go
if err := file.Chmod(0664); err != nil {
	fmt.Println(err)
	return err
}
```

或者将 ok-pattern 的获取放置在 if 语句的初始化部分，然后进行判断：

习惯用法

```go
if value, ok := readData(); ok {
…
}
```

如果您像下面一样，没有为多返回值的函数准备足够的变量来存放结果：

```go
func mySqrt(f float64) (v float64, ok bool) {
	if f < 0 { return } // error case
	return math.Sqrt(f),true
}

func main() {
	t := mySqrt(25.0)
	fmt.Println(t)
}
```

您会得到一个编译错误：`multiple-value mySqrt() in single-value context`。

正确的做法是：

```go
t, ok := mySqrt(25.0)
if ok { fmt.Println(t) }
```

将字符串转换为整数时，且确定转换一定能够成功时，可以将 Atoi 函数进行一层忽略错误的封装：

```go
func atoi (s string) (n int) {
	n, _ = strconv.Atoi(s)
	return
}
```

## switch 结构

相比较 C 和 Java 等其它语言而言，Go 语言中的 switch 结构使用上更加灵活。它接受任意形式的表达式：

```go
switch var1 {
	case val1:
		...
	case val2:
		...
	default:
		...
}
```

变量 `var1` 可以是任何类型，而 `val1` 和 `val2` 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。前花括号 `{` 必须和 `switch` 关键字在同一行。

您可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：`case val1, val2, val3`。

每一个 case 分支都是唯一的，从上至下逐一测试，直到匹配为止。（ Go 语言使用快速的查找算法来测试 switch 条件与 case 分支的匹配情况，直到算法匹配到某个 case 或者进入 default 条件为止。）

一旦成功地匹配到某个分支，在执行完相应代码后就会退出整个 switch 代码块，也就是说您不需要特别使用 break 语句来表示结束。

如果在执行完每个分支的代码后，还希望继续执行后续分支的代码，可以使用 `fallthrough` 关键字来达到目的。

```go
switch i {
	case 0: // 空分支，只有当 i == 0 时才会进入分支
	case 1:
		f() // 当 i == 0 时函数不会被调用
}
```

并且：

```go
switch i {
	case 0: fallthrough
	case 1:
		f() // 当 i == 0 时函数也会被调用
}
```

可选的 `default` 分支可以出现在任何顺序，但最好将它放在最后。它的作用类似与 `if-else` 语句中的 else，表示不符合任何已给出条件时，执行相关语句。

switch 语句还可以被用于 `type-switch`来判断某个 `interface` 变量中实际存储的变量类型。

```go
k := 6
switch k {
case 4:
  fmt.Println("was <= 4")
  fallthrough
case 5:
  fmt.Println("was <= 5")
  fallthrough
case 6:
  fmt.Println("was <= 6")
  fallthrough
case 7:
  fmt.Println("was <= 7")
  fallthrough
case 8:
  fmt.Println("was <= 8")
  fallthrough
default:
  fmt.Println("default case")
}
```

输出结果

```
was <= 6
was <= 7
was <= 8
default case
```

## for 结构

重复执行某些语句，Go 语言中您只有 for 结构可以使用。这个 for 结构比其它语言中的更为灵活。

>其它许多语言中也没有发现和 `do while` 完全对等的 `for` 结构，可能是因为这种需求并不是那么强烈。

### 基于计数器的迭代

最简单的基于计数器的迭代，基本形式为：

```go
for 初始化语句; 条件语句; 修饰语句 {}
```

for.go

```go
package main

import "fmt"

func main() {
	for i := 0; i < 5; i++ {
		fmt.Printf("This is the %d iteration\n", i)
	}
}
```

这三部分组成的循环的头部，它们之间使用分号 `;` 相隔，但并不需要括号 `()` 将它们括起来。例如：`for (i = 0; i < 10; i++) { }`，这是无效的代码！

>永远不要在循环体内修改计数器，这在任何语言中都是非常差的实践！

可以在循环中同时使用多个计数器：

```go
for i, j := 0, N; i < j; i, j = i+1, j-1 {}
```

>得益于 Go 语言具有的平行赋值的特性

将两个 for 循环嵌套起来：

```go
for i:=0; i<5; i++ {
	for j:=0; j<10; j++ {
		println(j)
	}
}
```

如果您使用 for 循环迭代一个 Unicode 编码的字符串，会发生什么？


```go
package main

import "fmt"

func main() {
	str := "Go is a beautiful language!"
	fmt.Printf("The length of str is: %d\n", len(str))
	for ix :=0; ix < len(str); ix++ {
		fmt.Printf("Character on position %d is: %c \n", ix, str[ix])
	}
	str2 := "日本語"
	fmt.Printf("The length of str2 is: %d\n", len(str2))
	for ix :=0; ix < len(str2); ix++ {
		fmt.Printf("Character on position %d is: %c \n", ix, str2[ix])
	}
}
```

输出：

```
The length of str is: 27
Character on position 0 is: G
Character on position 1 is: o
Character on position 2 is:   
Character on position 3 is: i
Character on position 4 is: s
Character on position 5 is:   
Character on position 6 is: a
Character on position 7 is:   
Character on position 8 is: b
Character on position 9 is: e
Character on position 10 is: a
Character on position 11 is: u
Character on position 12 is: t
Character on position 13 is: i
Character on position 14 is: f
Character on position 15 is: u
Character on position 16 is: l
Character on position 17 is:   
Character on position 18 is: l
Character on position 19 is: a
Character on position 20 is: n
Character on position 21 is: g
Character on position 22 is: u
Character on position 23 is: a
Character on position 24 is: g
Character on position 25 is: e
Character on position 26 is: !
The length of str2 is: 9
Character on position 0 is: æ
Character on position 1 is: �
Character on position 2 is: ¥
Character on position 3 is: æ
Character on position 4 is: �
Character on position 5 is: ¬
Character on position 6 is: è
Character on position 7 is: ª
Character on position 8 is: �
```

### 基于条件判断的迭代

for 结构的第二种形式是没有头部的条件判断迭代（类似其它语言中的 `while` 循环），基本形式为：`for` 条件语句 `{}`。

您也可以认为这是没有初始化语句和修饰语句的 `for` 结构，因此 `;;` 便是多余的了。

```go
package main

import "fmt"

func main() {
	var i int = 5

	for i >= 0 {
		i = i - 1
		fmt.Printf("The variable i is now: %d\n", i)
	}
}
```

### 无限循环

```go

```
```go

```
```go

```
