
+ 布尔型
+ 数字型
+ 字符型

## 布尔型

```go
var aVar = 10
aVar == 5 -> false
aVar == 10 -> true

var aVar = 10
aVar != 5 -> true
aVar != 10 -> false
```

>Go 对于值之间的比较有非常严格的限制
+ 只有两个类型相同的值才可以进行比较，如果值的类型是接口（interface），它们也必须都实现了相同的接口。
+ 如果其中一个值是常量，那么另外一个值的类型必须和该常量类型相兼容的。如果以上条件都不满足，则其中一个值的类型必须在被转换为和另外一个值的类型相同之后才可以进行比较。

`!`, `&&`, `||`


## 数字型

### 整型 int 和浮点型 float

支持整型和浮点型数字，并且原生支持复数，其中位的运算采用补码

Go 也有基于架构的类型，例如：int、uint 和 uintptr。

这些类型的长度都是根据运行程序所在的操作系统类型所决定的：

+ int 和 uint 在 32 位操作系统上，它们均使用 32 位（4 个字节），在 64 位操作系统上，它们均使用 64 位（8 个字节）。
+ uintptr 的长度被设定为足够存放一个指针即可。

__Go 语言中没有 float 类型__。

与操作系统架构无关的类型都有固定的大小，并在类型的名称中就可以看出来：

### 整数：

```go
int8（-128 -> 127）
int16（-32768 -> 32767）
int32（-2,147,483,648 -> 2,147,483,647）
int64（-9,223,372,036,854,775,808 -> 9,223,372,036,854,775,807）
```

### 无符号整数：

```go
uint8（0 -> 255）
uint16（0 -> 65,535）
uint32（0 -> 4,294,967,295）
uint64（0 -> 18,446,744,073,709,551,615）
```

### 浮点型（IEEE-754 标准）：

```go
float32（+- 1e-45 -> +- 3.4 * 1e38）
float64（+- 5 * 1e-324 -> 107 * 1e308）
```

int 型是计算最快的一种类型。

整型的零值为 0，浮点型的零值为 0.0。

float32 精确到小数点后 7 位，float64 精确到小数点后 15 位。由于精确度的缘故，你在使用 `==` 或者 `!=` 来比较浮点数时应当非常小心。你最好在正式使用前测试对于精确度要求较高的运算。

你应该尽可能地使用 float64，因为 math 包中所有有关数学运算的函数都会要求接收这个类型。

通过增加前缀 `0` 来表示 8 进制数（如：077），增加前缀 `0x` 来表示 16 进制数（如：0xFF），以及使用 `e` 来表示 10 的连乘（如： 1e3 = 1000，或者 6.022e23 = 6.022 x 1e23）。

`a := uint64(0)` 来同时完成类型转换和赋值操作，这样 a 的类型就是 uint64。

Go 中不允许不同类型之间的混合使用，但是对于常量的类型限制非常少，因此允许常量之间的混合使用

```go
package main

func main() {
	var a int
	var b int32
	a = 15
	b = a + a	 // 编译错误
	b = b + 5    // 因为 5 是常量，所以可以通过编译
}
```

## 复数

+ complex64 (32 位实数和虚数)
+ complex128 (64 位实数和虚数)

复数使用 `re+imI` 来表示，其中 re 代表实数部分，im 代表虚数部分，I 代表根号负 1。

```go
var c1 complex64 = 5 + 10i
fmt.Printf("The value is: %v", c1)
// 输出： 5 + 10i
```

## 位运算

位运算只能用于整数类型的变量，且需当它们拥有等长位模式时。

`%b` 是用于表示位的格式化标识符。

### 二元运算符

按位与 `&`：

对应位置上的值经过和运算结果，并将 T（true）替换为 1，将 F（false）替换为 0

```go
  1 & 1 -> 1
  1 & 0 -> 0
  0 & 1 -> 0
  0 & 0 -> 0
  ```

按位或 `|`：

对应位置上的值经过或运算结果，并将 T（true）替换为 1，将 F（false）替换为 0

```go
  1 | 1 -> 1
  1 | 0 -> 1
  0 | 1 -> 1
  0 | 0 -> 0
```

按位异或 `^`：

对应位置上的值根据以下规则组合：

```go
  1 ^ 1 -> 0
  1 ^ 0 -> 1
  0 ^ 1 -> 1
  0 ^ 0 -> 0
```

位清除 `&^`：将指定位置上的值设置为 0。

### 一元运算符

按位补足 `^`：

该运算符与异或运算符一同使用，即 `m^x`，对于无符号 `x` 使用“全部位设置为 1”，对于有符号 `x` 时使用 `m=-1`。例如：

```go
^10 = -01 ^ 10 = -11
```

位左移 `<<`：

用法：`bitP << n`。

bitP 的位向左移动 n 位，右侧空白部分使用 0 填充；如果 n 等于 2，则结果是 2 的相应倍数，即 2 的 n 次方。例如：

```go
1 << 10 // 等于 1 KB
1 << 20 // 等于 1 MB
1 << 30 // 等于 1 GB
```

位右移 `>>`：

用法：`bitP >> n`。

bitP 的位向右移动 n 位，左侧空白部分使用 0 填充；如果 n 等于 2，则结果是当前值除以 2 的 n 次方。
当希望把结果赋值给第一个操作数时，可以简写为 `a <<= 2` 或者 `b ^= a & 0xffffffff`。

位左移常见实现存储单位的用例

使用位左移与 iota 计数配合可优雅地实现存储单位的常量枚举：

```go
type ByteSize float64
const (
	_ = iota // 通过赋值给空白标识符来忽略值
	KB ByteSize = 1<<(10*iota)
	MB
	GB
	TB
	PB
	EB
	ZB
	YB
)
```

在通讯中使用位左移表示标识的用例

```go
type BitFlag int
const (
	Active BitFlag = 1 << iota // 1 << 0 == 1
	Send // 1 << 1 == 2
	Receive // 1 << 2 == 4
)

flag := Active | Send // == 3
```

### 逻辑运算符
Go 中拥有以下逻辑运算符：`==`、`!=`、`<`、`<=`、`>`、`>=`。

它们之所以被称为逻辑运算符是因为它们的运算结果总是为布尔值 bool。例如：

```go
b3:= 10 > 5 // b3 is true
```

## 运算符与优先级

下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：

```
优先级 	运算符
 7 		^ !
 6 		* / % << >> & &^
 5 		+ - | ^
 4 		== != < <= >= >
 3 		<-
 2 		&&
 1 		||
```

## 类型别名
当你在使用某个类型时，你可以给它起另一个名字，然后你就可以在你的代码中使用新的名字（用于简化名称或解决名称冲突）。

在 type TZ int 中，TZ 就是 int 类型的新名称（用于表示程序中的时区），然后就可以使用 TZ 来操作 int 类型的数据。


```go
package main
import "fmt"

type TZ int

func main() {
	var a, b TZ = 3, 4
	c := a + b
	fmt.Printf("c has the value: %d", c) // 输出：c has the value: 7
}
```


>类型别名得到的新类型并非和原类型完全相同，__新类型不会拥有原类型所附带的方法__；TZ 可以自定义一个方法用来输出更加人性化的时区信息。

## 字符类型

严格来说，这并不是 Go 语言的一个类型，__字符只是整数的特殊用例__。`byte` 类型是 `uint8` 的别名，对于只占用 1 个字节的传统 ASCII 编码的字符来说，完全没有问题。例如：`var ch byte = 'A'`；字符使用单引号括起来。

在 ASCII 码表中，A 的值是 65，而使用 16 进制表示则为 41，所以下面的写法是等效的：

```go
var ch byte = 65 或 var ch byte = '\x41'
```

>`\x` 总是紧跟着长度为 2 的 16 进制数

另外一种可能的写法是 `\` 后面紧跟着长度为 3 的八进制数，例如：`\377`

Go 同样支持 Unicode（UTF-8），因此字符同样称为 Unicode 代码点或者 `runes`，并在内存中使用 int 来表示。在文档中，一般使用格式 U+hhhh 来表示，其中 h 表示一个 16 进制数。其实 `rune` 也是 Go 当中的一个类型，并且是 int32 的别名。

在书写 Unicode 字符时，需要在 16 进制数之前加上前缀 `\u` 或者 `\U`。

因为 Unicode 至少占用 2 个字节，所以我们使用 int16 或者 int 类型来表示。如果需要使用到 4 字节，则会加上 `\U` 前缀；前缀 `\u` 则总是紧跟着长度为 4 的 16 进制数，前缀 `\U` 紧跟着长度为 8 的 16 进制数。

格式化说明符 %c 用于表示字符；当和字符配合使用时，%v 或 %d 会输出用于表示该字符的整数；%U 输出格式为 U+hhhh 的字符串（另一个示例见第 5.4.4 节）。

包 unicode 包含了一些针对测试字符的非常有用的函数（其中 ch 代表字符）：

+ 判断是否为字母：`unicode.IsLetter(ch)`
+ 判断是否为数字：`unicode.IsDigit(ch)`
+ 判断是否为空白符号：`unicode.IsSpace(ch)`

